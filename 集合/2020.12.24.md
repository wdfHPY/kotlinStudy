## 集合

#### `kotlin`相关集合概念

1. `List`: `List`是一个有序的集合.可以通过索引来访问集合中的元素
2. `Set`:`Set`是唯一元素的集合.是一组没有重复值的元素的集合
3. `Map`:是键值对的集合.键是唯一的,而值是可以重复的,每一个键都对应着一个值

#### `kotlin`集合类型

1. 针对`Kotlin`中存在的集合概念,kotlin Api 对每个集合概念都提供两种集合类型
   - 一种只读接口:该接口不可写,仅只读.
   - 一种可变接口:可以对集合中存在的元素进行删除,增加,修改value

2. **只读接口是型变的**,只读的类型的子类型是可以代替父类型的.map 集合在键key上是型变的,在value上不是.
3. **可变接口不是型变的**

#### Collection 接口

1. Collection 接口是只读.Collection继承自`Iterable`接口,Collection接口可以遍历其中的元素.当然,kotlin也提供了可变的Collection的接口.`MutableCollection`相对于Collection提供了修改,删除,添加的api
2. `List`和`Set`
   - List: List<T> 以指定的顺序存储元素,并提供使用索引访问元素的方法。索引从 0 开始 ‒ 第一个元素的索引 ‒ 直到 最后一个元素的索引 即 `(list.size - 1) `。如果两个 List 在相同的位置具有相同大小和相同结构的元素,则认为它们是相等的。
   - `MutableList<T>`是可写的List,是可以在特定位置添加或删除元素。
     - 在 `Kotlin` 中,`List` 的默认实现是` ArrayList`,可以将其视为可调整大小的数组。
   - Set<T>:是用来用来存储唯一的元素,Set集合元素顺序通常是未定义的.两个 set 具有相同的大小并且对于一个 set 中的每个元素都能在另一个 set 中存在相同元素,则两个 set 相等
     - Set的默认的实现是`LinkedHashSet`.一般Set存储唯一的元素,元素的顺序不可预测的.`LinkedHashSet`元素的顺序即为插入的顺序.故`LinkedHashSet`元素顺序是可以预测的.
     - Set还提供另外的一种实现方式.`HashSet`.不声明元素的顺序,`HashSet `只需要较少的内存来存储相同数量的元素。(**Source Code Study**)

#### Map 

1. `Map `键值对类型的话并不是Collection的继承者.(**Source Code Study**)
2. `Map` 接口提供特定的函数进行通过键访问值、搜索键和值等操作。.keys来访问键的集合,.values来访问值的集合,无论键值对的顺序如何,包含相同键值对的两个 Map 是相等的。
3. `MutableMap` 是一个具有写操作的 Map 接口,可以使用该接口添加一个新的键值对或更新给定键的值。
4. Map的默认的默认实现和Set的差不多.Map 的默认实现 ‒ `LinkedHashMap` ‒ 迭代 Map 时保留元素插入的顺序。 反之,另一种实现 ‒ `HashMap` ‒ 不声明元素的顺序。(**Source Code Study**)



#### 构造集合

1. 标准库函数` listOf<T>()`、 `setOf<T>()`、 `mutableListOf<T>()`、` mutableSetOf<T>()`。 如果以逗号分隔的集合元素列表作为参数,编译器会自动检测元素类型。创建空集合时,须明确指定类型。
2. Map的创建同样使用`mapof()`标准库函数来创建,mapof接受的参数是Pair类型,但是这样做效率不高,使用Scope Function . apply 来创建Map是一个不错的方法.
3. 上面说了集合的默认实现,当然也可以创建具体类型的集合,比如`LinkedList,HashMap`等等



#### 集合常用`API`的操作

1. 集合的复制.`toList()、 toMutableList()、 toSet()` 等等。创建了集合的快照结果是创建了一个具有相同元素的新集合 如果在源集合中添加或删除元素,则不会影响副本。
2. 集合的过滤 .fliter
3. 集合的映射 .map
4. 集合生成相关的map associateWith



#### Collection 迭代器 Iterator



#### 区间: 区间的主要的操作是`contains`

1. 创建区间：使用操作符号`..`来创建一个区间．区间和数学上[]集合是等价，可以使用 in 或者!in 来进行判断是否在一个区间中.
2. 创建一个反向迭代的区间的话,使用`downTo`函数而不是`..`来创建区间.
3. 在区间中使用`step`函数来指定步长.
4. 指定前开后闭的区间使用util函数.

#### 数列

1. 上面使用..来创建一个区间.区间本质上是一个数列
2. 数列具有三个基本属性: first 元素、 last 元素和一个非零的 step 。 首个元素为 first ,后续元素是前一个元
   素加上一个 step 。
   - first 元素
   - step 步长
   - last 元素
3. 通过迭代数列隐式创建区间时,此数列的 first 与 last 元素是区间的端点,step 为 1
4. 请注意: `last` 元素并非总与指定的结束值相同
5. 数列实现了Iterator<T> 接口,那么就各种集合函数就可以在数列上进行调用.

#### 序列 Sequence<T>

- 序列API的集合操作主要存在两种

  - 中间操作:中间操作始终都会是惰性的,换一句话说,序列的中间操作都是会延迟的.只有执行到末端操作时才会执行中间操作.区别中间操作还是末端操作的标准的话就在于API的操作的返回值.如果返回值是一个Sequence<T>的话,那么很显然,这是一个中间操作.
  - 末端操作
    - 末端操作会计算中间的所有的延迟计算.一次末端操作的结果返回的是一个结果.返回的值是一个非Sequence<T>的结果.它可以返回的是一个具体的结果类型,比如Int,Boolean类型

- 创建序列的方式

  - 创建序列的方式存在三种

    - 使用Iterable的扩展函数的asSequence()来创建序列
    - 使用generateSequnence函数来生成一个序列
    - 使用Sequence的扩展函数constraninOnce生成一次性的序列

  - 序列性能优化的原理

    - ```kotlin
      fun main(args: Array<String>){
          (0..10)
              .asSequence()
              .map { it + 1 }
              .filter { it % 2 == 0 }
              .count { it < 6 }
              .run {
                  println("by using sequence result is $this")
              }
      }
      ```

    - 序列的基本原理是惰性求值,在进行中间操作时,是不会产生中间数据的结果的.只会等待进行末端擦操作时才会进行求值.也就是上述例子中0~10中的每个数据元素都是先执行map操作，接着马上执行filter操作。然后下一个元素也是先执行map操作，接着马上执行filter操作。

    - 如果是集合普通的操作的话,每一次中间的集合操作都是需要存储中间的结果的.上面的例子如何视同集合来完成的话,那么就会将最新的数据集合存放在新的集合当中.一直重复的进行开启集合空间,针对上次集合迭代生成新集合.知道产生最终的结果

    - 

![img](https://user-gold-cdn.xitu.io/2018/6/5/163cf76b453c2719?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

- 通过上述序列和集合运行图表示的话,序列是针对序列中每一个元素来进行中间各个操作的.在进行末端操作的之前就可以过滤一些不符合条件的元素,避免这个不符合条件的元素后续的中间操作.这也是懒操作的好处.

- 
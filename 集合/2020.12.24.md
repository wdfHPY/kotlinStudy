## 集合

#### `kotlin`相关集合概念

1. `List`: `List`是一个有序的集合.可以通过索引来访问集合中的元素
2. `Set`:`Set`是唯一元素的集合.是一组没有重复值的元素的集合
3. `Map`:是键值对的集合.键是唯一的,而值是可以重复的,每一个键都对应着一个值

#### `kotlin`集合类型

1. 针对`Kotlin`中存在的集合概念,kotlin Api 对每个集合概念都提供两种集合类型
   - 一种只读接口:该接口不可写,仅只读.
   - 一种可变接口:可以对集合中存在的元素进行删除,增加,修改value

2. **只读接口是型变的**,只读的类型的子类型是可以代替父类型的.map 集合在键key上是型变的,在value上不是.
3. **可变接口不是型变的**

#### Collection 接口

1. Collection 接口是只读.Collection继承自`Iterable`接口,Collection接口可以遍历其中的元素.当然,kotlin也提供了可变的Collection的接口.`MutableCollection`相对于Collection提供了修改,删除,添加的api
2. `List`和`Set`
   - List: List<T> 以指定的顺序存储元素,并提供使用索引访问元素的方法。索引从 0 开始 ‒ 第一个元素的索引 ‒ 直到 最后一个元素的索引 即 `(list.size - 1) `。如果两个 List 在相同的位置具有相同大小和相同结构的元素,则认为它们是相等的。
   - `MutableList<T>`是可写的List,是可以在特定位置添加或删除元素。
     - 在 `Kotlin` 中,`List` 的默认实现是` ArrayList`,可以将其视为可调整大小的数组。
   - Set<T>:是用来用来存储唯一的元素,Set集合元素顺序通常是未定义的.两个 set 具有相同的大小并且对于一个 set 中的每个元素都能在另一个 set 中存在相同元素,则两个 set 相等
     - Set的默认的实现是`LinkedHashSet`.一般Set存储唯一的元素,元素的顺序不可预测的.`LinkedHashSet`元素的顺序即为插入的顺序.故`LinkedHashSet`元素顺序是可以预测的.
     - Set还提供另外的一种实现方式.`HashSet`.不声明元素的顺序,`HashSet `只需要较少的内存来存储相同数量的元素。(**Source Code Study**)

#### Map 

1. `Map `键值对类型的话并不是Collection的继承者.(**Source Code Study**)
2. `Map` 接口提供特定的函数进行通过键访问值、搜索键和值等操作。.keys来访问键的集合,.values来访问值的集合,无论键值对的顺序如何,包含相同键值对的两个 Map 是相等的。
3. `MutableMap` 是一个具有写操作的 Map 接口,可以使用该接口添加一个新的键值对或更新给定键的值。
4. Map的默认的默认实现和Set的差不多.Map 的默认实现 ‒ `LinkedHashMap` ‒ 迭代 Map 时保留元素插入的顺序。 反之,另一种实现 ‒ `HashMap` ‒ 不声明元素的顺序。(**Source Code Study**)



#### 构造集合

1. 标准库函数` listOf<T>()`、 `setOf<T>()`、 `mutableListOf<T>()`、` mutableSetOf<T>()`。 如果以逗号分隔的集合元素列表作为参数,编译器会自动检测元素类型。创建空集合时,须明确指定类型。
2. Map的创建同样使用`mapof()`标准库函数来创建,mapof接受的参数是Pair类型,但是这样做效率不高,使用Scope Function . apply 来创建Map是一个不错的方法.
3. 上面说了集合的默认实现,当然也可以创建具体类型的集合,比如`LinkedList,HashMap`等等



#### 集合常用`API`的操作

1. 集合的复制.`toList()、 toMutableList()、 toSet()` 等等。创建了集合的快照结果是创建了一个具有相同元素的新集合 如果在源集合中添加或删除元素,则不会影响副本。
2. 集合的过滤 .fliter
3. 集合的映射 .map
4. 集合生成相关的map associateWith
package com.lonbon.kotlin

/*
*   同步和异步：
*       1. 同步、异步和阻塞、非阻塞的概念可能在学习时存在一定的混淆。
*       2. 同步、异步本质上是描述调用结果如何返回给调用者的方式。一般获取结果只要两个方式，第一种是调用者主动
*   去获取结果。第二种是被调用者告诉调用调用者结果，第一种方式对应着同步，第二种方式对应着异步。
*       3. 上面仅仅是从概念上理解： 调用者 A 调用 B，在这里B是一个耗时操作。 同步的方式便是 A 去主动获取 B的
*   结果。可能 A的状态 是停止不动，可能 A的状态是 继续运行，但 A调用B之后的状态不影响获取结果的方式。调用者的状态是 阻塞
*   和非阻塞的概念。同步始终都是 A 去 主动获取 B的结果。异步对应着第二种。B 会将运行的结果告诉 A。A调用 B之后
*   并不会去主动获取 B 的结果， B 的 结果 A 不用关系，当出结果时 B 将结果 告诉 A。
*       4. 阻塞 、非阻塞本质上是描述调用者调用之后的状态的。调用者调用之后，如果停止不动，不会向下执行，这就对应
*   着阻塞的模式。相反，调用者调用之后，调用者继续向下执行，那么便是非阻塞的模式。 以同步的方式来举例， A 主动获取 B
*   的结果。 A 的状态 是不向下执行，这就对应着的阻塞。相对的， A 的状态 是继续的向下去执行的话，那么对应着非阻塞。
*
*   从[代码角度]上理解同步和异步：
*   协程 通过 将异步程序同步化的方式 来解决多线程中 callback。
*   具体如何实现 异步程序同步化 暂时不管。协程在使用中可以摆脱比较跳脱的回调的代码写法，整个程序是同步的。
*   所谓同步可以理解为代码的顺序的执行，同步的相对面就是异步。而callBack是一种很典型的异步。其实， 同步这个
*   词语很容易产生一定的误导，认为同步就是一起，同步执行便是一起执行。（一起执行不是并发而是并行） 同步执行
*   可以简单的理解为顺序执行。
*
*   协程是异步非阻塞。
*
*   而异步执行肯定是非顺序执行。
*
*   协程: 可以理解为协作完成某一些任务。与之相对应便是非协作模式，举个例子，某一项任务需要请求两个网络接口才能
*   去Ui的更新。如果使用异步的写法（callBack的写法），那么就需要进行多层callBack函数嵌套。
            api.getAvatar(user, callback)
            api.getCompanyLogo(user, callback)
    使用callBack的写法来说：
            api.getAvatar(user) { avatar -&gt;
                api.getCompanyLogo(user) { logo -&gt;
                    show(merge(avatar, logo))
            }
       }
    强行将可以并发的程序通过嵌套的方式来同步化。这种同步化手段缺点很大，使之前可以并发请求的两个网络请求存在顺序性
    其效率降低。整体时间可以为并发的两倍。
            coroutineScope.launch(Dispatchers.Main) {
                val avatar = async { api.getAvatar(user) }    // 网络请求1
                val logo = async { api.getCompanyLogo(user) } // 网络请求2
                val merged = suspendingMerge(avatar, logo)    // 合并结果
                show(merged) // 更新 UI
            }
    kotlin 的协程很方便处理了需要协作完成Job的任务。相对于回调成倍的提高了执行的效率。
* */
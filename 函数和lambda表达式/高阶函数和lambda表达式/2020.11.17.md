package top.wangdfeng

//高阶函数与lambda表达式:高阶函数是将函数作为参数或者返回值的函数
/*
fun <T, R> Collection<T>.fold(
        initial: R,
        combine: (acc: R, nextElement: T) -> R
): R {
    var accumulator: R = initial
    for (element: T in this) {
        accumulator = combine(accumulator, element)
    }
    return accumulator
}*/

//上面fold函数便是典型的高阶函数,fold函数支持接受两个参数,一个参数是初始值,另外一个参数便是函数combine.
/*
*   combine 函数接受两个参数R 和 T combine的返回值是R
*   for 循环会遍历Collections然后进行累加的操作.最终返回结果.
*   fold 函是一个扩展函数.this 便代表着Collection本身
* */

//下面来调用Collection的扩展函数fold,既然需要调用Collection函数的话,那么就需要的去传参
/**
 * 那么就需要传递一个函数类型的实例给fold函数.存在两种形式给函数类型的实例
 *      1.lambda表达式
 *      2.匿名函数
 * Collection的扩展会遍历集合的然后会将值和初始值来执行相同的lambda表达式
 */


/**
 * 
 */

fun main() {
    val items = listOf(1,2,3,4)
    println(items.fold(20,{
        acc,i ->
        val result = acc - i
// lambda 表达式中的最后一个表达式是返回值:
        result
    }))


    /**
     * lambda表达式的参数类型是可选的,如果能够通过类型进行推导出来的话.
     */
    /**
     * 调用传参时:
     *       1.使用函数类型的实例.lambda 表达式或者匿名函数
     *       2.函数引用  val product = items.fold(1, Int::times)
     * 通过::来进行函数引用
     */
}

